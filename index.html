<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AstroDomus v3.6 - Traditional Astrology Chart</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="chart-section">
            <div class="controls">
                <button id="zodiacBtn" class="active" onclick="setMode('zodiac')">Zodiac (Z)</button>
                <button id="housesBtn" onclick="setMode('houses')">Houses (X)</button>
                <button id="planetsBtn" onclick="setMode('planets')">Planets (V)</button>
                <button id="drawBtn" onclick="setMode('draw')">Draw (W)</button>
                <button onclick="resetChart()">Reset (R)</button>
                <select id="planetSelect" style="display:none;">
                    <option value="">Add Symbols...</option>
                    <option value="☉">☉ Sun</option><option value="☽">☽ Moon</option><option value="☿">☿ Mercury</option>
                    <option value="♀">♀ Venus</option><option value="♂">♂ Mars</option><option value="♃">♃ Jupiter</option>
                    <option value="♄">♄ Saturn</option><option value="☊">☊ North Node</option><option value="☋">☋ South Node</option>
                    <option value="⦻">⦻ Part of Fortune</option>
                    <option value="℞">℞ Retrograde</option>
                    <option value="⭐">⭐ Star</option>
                </select>
            </div>
            <div class="draw-controls" id="drawControls" style="display:none;">
                <label>Tool: 
                    <select id="drawTool">
                        <option value="pencil">Pencil</option>
                        <option value="line">Line</option>
                        <option value="eraser">Eraser</option>
                    </select>
                </label>
                <label>Color: <input type="color" id="drawColor" value="#FF6666"></label>
                <label>Size: <input type="range" id="drawSize" min="1" max="10" value="2"></label>
                <span id="sizeValue">2px</span>
                <button onclick="clearDrawing()">Clear Drawing</button>
            </div>
            <div class="controls">
                <label><input type="checkbox" id="hideZodiac"> Hide Zodiac Signs (H)</label>
                <label><input type="checkbox" id="hidePlanets"> Hide Planets (K)</label>
                <label><input type="checkbox" id="showInfo"> Details (D)</label>
                <label><input type="checkbox" id="showDignities"> Dignities (G)</label>
                <label><input type="checkbox" id="showQualities"> Qualities (Q)</label>
                <label><input type="checkbox" id="showElements"> Elements (M)</label>
                <label><input type="checkbox" id="showSeason"> Seasons (S)</label>
                <label><input type="checkbox" id="showSolarIngress"> Solar Ingress Dates (I)</label>
                <label><input type="checkbox" id="showFigureSigns"> Figures of the Signs (F)</label>
                <label><input type="checkbox" id="showFertileBarren"> Fertile and Barren Signs (B)</label>
                <label><input type="checkbox" id="showSignTemps"> Sign Temps (T)</label>
                <label><input type="checkbox" id="showSignGenders"> Sign Gender (N)</label>
                <label><input type="checkbox" id="showAngles"> Angles (ASC/DSC/MC/IC) (A)</label>
            </div>
            <div class="controls">
                <label><input type="checkbox" id="showMoonCircle" checked> Moon Circle (☽)</label>
                <label><input type="checkbox" id="showMercuryCircle" checked> Mercury Circle (☿)</label>
                <label><input type="checkbox" id="showVenusCircle" checked> Venus Circle (♀)</label>
                <label><input type="checkbox" id="showSunCircle" checked> Sun Circle (☉)</label>
                <label><input type="checkbox" id="showMarsCircle" checked> Mars Circle (♂)</label>
                <label><input type="checkbox" id="showJupiterCircle" checked> Jupiter Circle (♃)</label>
                <label><input type="checkbox" id="showSaturnCircle" checked> Saturn Circle (♄)</label>
                <label><input type="checkbox" id="showPlanetTemps"> Planet Temps (1)</label>
                <label><input type="checkbox" id="showPlanetSect"> Planet Sect (2)</label>
                <label><input type="checkbox" id="showBeneficMaleficPlanets"> Benefic planets / Malefic planets (3)</label>
                <label><input type="checkbox" id="showPlanetGender"> Planet Gender (4)</label>
                <label><input type="checkbox" id="showHouseSect"> House Sect (5)</label>
                <label><input type="checkbox" id="showHouseTypes"> House Types (6)</label>
                <label><input type="checkbox" id="showhouseJoy"> House Joy (7)</label>
                <label><input type="checkbox" id="showEgyptianBounds"> Egyptian Bounds (8)</label>
                <label><input type="checkbox" id="showPtolemyBounds"> Ptolemy Bounds (9)</label>
                <label><input type="checkbox" id="showChaldeanBounds"> Chaldean Bounds (0)</label>
                <label><input type="checkbox" id="showDecans"> Decans (O)</label>
                <label><input type="checkbox" id="showDirections"> House Directions (J)</label>
                <label><input type="checkbox" id="freeSymbolMovement"> Free Symbol Movement (U)</label>
                <label><input type="checkbox" id="showPlanetCircles" checked> Show Planet Circles</label>
            </div>
            <div id="info">Select mode to interact with chart</div>
            <canvas id="chart" width="800" height="800"></canvas>
            <div class="eraser-indicator" id="eraserIndicator"></div>
        </div>
        <div class="keywords-section">
            <div class="keywords" id="keywordsPanel">
                <h3>Traditional Astrology Keywords</h3>
                <p>Click on any planet, zodiac sign, or house to see traditional keywords and meanings.</p>
            </div>
        </div>
    </div>
<script>
// Professional Astrology Chart Engine - Optimized (v5.0)
const AstrologyChart = (() => {
    // Core Configuration & State
    const CONFIG = {
    canvas: document.getElementById('chart'),
        ctx: document.getElementById('chart').getContext('2d'),
        center: 400,
        radii: {
            outer: 295,      // Outermost zodiac ring
            egyptian: 270,   // Egyptian bounds (just inside outer)
            ptolemy: 245,    // Ptolemy bounds (inside Egyptian)
            chaldean: 220,   // Chaldean bounds (inside Ptolemy)  
            decan: 205,      // Decan ring (inside all bounds)
            inner: 180,      // Inner house ring
            // Ptolemaic planetary circles (from outer to inner)
            saturn: 160, jupiter: 140, mars: 120, sun: 100, venus: 80, mercury: 60, moon: 40,
            aspect: 20       // Central aspect circle
        },
        colors: {bg: '#0a0a0a', ring: '#333', text: '#fff', accent: '#FFD700', selected: '#FF6666', dim: '#666'},
        isMobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768
    };

    const PTOLEMAIC_CIRCLES = {
        '☽': 'moon',     // Moon - 1st circle
        '☿': 'mercury',  // Mercury - 2nd circle  
        '♀': 'venus',    // Venus - 3rd circle
        '☉': 'sun',      // Sun - 4th circle
        '♂': 'mars',     // Mars - 5th circle
        '♃': 'jupiter',  // Jupiter - 6th circle
        '♄': 'saturn'    // Saturn - 7th circle
    };

    const FREE_SYMBOLS = ['℞', '⭐', '☊', '☋', '⦻']; // These symbols can be placed anywhere
    
    let state = {
        mode: 'zodiac', isDragging: false, dragTarget: null, zodiacOffset: 0, lastZodiacAngle: 0,
        isDrawing: false, isErasing: false, drawingPaths: [], currentPath: [], lineStartPoint: null,
        selectedSign: null, selectedPlanet: null, ascendantOffset: 0, dragAngleControl: null,
        hideZodiac: false, hidePlanets: false
    };

    // Compressed Astrology Data Repository
    const ASTRO_DATA = {
        signs: ['♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓'],
        signNames: ['Aries','Taurus','Gemini','Cancer','Leo','Virgo','Libra','Scorpio','Sagittarius','Capricorn','Aquarius','Pisces'],
        seasons: ['Spring - Hot and Moist','Spring - Hot and Moist','Spring - Hot and Moist','Summer - Hot and Dry','Summer - Hot and Dry','Summer - Hot and Dry','Autumn - Cold and Dry','Autumn - Cold and Dry','Autumn - Cold and Dry','Winter - Cold and Moist','Winter - Cold and Moist','Winter - Cold and Moist'],
        qualities: ['Cardinal','Fixed','Mutable','Cardinal','Fixed','Mutable','Cardinal','Fixed','Mutable','Cardinal','Fixed','Mutable'],
        houseNames: ['1st House (Self) - Temple of Mercury','2nd House (Money) - Typhons dwelling','3rd House (Siblings) - Temple of the Moon','4th House (Home) - Temple of Saturn','5th House (Children)','6th House (Health)','7th House (Marriage)','8th House (Death) Typhons dwelling','9th House (Religion) - Temple of the Sun','10th House (Career) - Temple of Venus','11th House (Friends) - Temple of Jupiter','12th House (Hidden)'],
        decans: [['♂','☉','♀'],['☿','☽','♄'],['♃','♂','☉'],['♀','☿','☽'],['♄','♃','♂'],['☉','♀','☿'],['☽','♄','♃'],['♂','☉','♀'],['☿','☽','♄'],['♃','♂','☉'],['♀','☿','☽'],['♄','♃','♂']],
        solarIngress: ['Mar 21 - Apr 19','Apr 20 - May 20','May 21 - Jun 20','Jun 21 - Jul 22','Jul 23 - Aug 22','Aug 23 - Sep 22','Sep 23 - Oct 22','Oct 23 - Nov 21','Nov 22 - Dec 21','Dec 22 - Jan 19','Jan 20 - Feb 18','Feb 19 - Mar 20'],
        figureSigns: ['Bestial','Bestial','Human','Aquatic','Bestial','Human','Human','Aquatic','Half-Beast Half-Human','Half-Beast Half-Human','Human','Aquatic'],
        fertileBarren: ['Moderately Barren','Moderately Fertile','Fertile','Fertile','Barren','Barren','Moderately Fertile','Fertile','Moderately Fertile','Moderately Barren','Moderately Barren','Fertile'],
        elements: ['Fire','Earth','Air','Water','Fire','Earth','Air','Water','Fire','Earth','Air','Water'],
        signTemps: ['Choleric','Melancholic','Sanguine','Phlegmatic','Choleric','Melancholic','Sanguine','Phlegmatic','Choleric','Melancholic','Sanguine','Phlegmatic'],
        signGenders: ['Male','Female','Male','Female','Male','Female','Male','Female','Male','Female','Male','Female'],
        houseDirections: ['East','East-Northeast','Northeast','North','North-Northwest','Northwest','West','West-Southwest','Southwest','South','South-Southeast','Southeast'],
        planetTemps: {'☉':'Choleric','☽':'Phlegmatic','☿':'V','♀':'Sanguine/Phlegmatic','♂':'Choleric','♃':'Sanguine','♄':'Melancholic','☊':'V','☋':'V','⦻':'V'},
        planetSect: {'☉':'Diurnal','☽':'Nocturnal','☿':'C','♀':'Nocturnal','♂':'Diurnal','♃':'Diurnal','♄':'Diurnal','☊':'Nocturnal','☋':'Diurnal','⦻':'C'},
        beneficMaleficPlanets: {'☉':'','☽':'','☿':'','♀':'Benefic','♂':'Malefic','♃':'Benefic','♄':'Malefic','☊':'','☋':'','⦻':'C'},
        planetGender: {'☉':'Male','☽':'Female','☿':'N','♀':'Female','♂':'Male','♃':'Male','♄':'Male','☊':'N','☋':'N','⦻':'N'},
        houseSect: ['Nocturnal','Nocturnal','Nocturnal','Nocturnal','Nocturnal','Nocturnal','Diurnal','Diurnal','Diurnal','Diurnal','Diurnal','Diurnal'],
        houseTypes: ['Angular','Succedent','Cadent','Angular','Succedent','Cadent','Angular','Succedent','Cadent','Angular','Succedent','Cadent'],
        houseJoy: ['Joy ☿ (Mercury)','','Joy ☽ (Moon)','','Joy ♀ (Venus)','Joy ♂ (Mars)','','','Joy ☉ (Sun)','','Joy ♃ (Jupiter)','Joy ♄ (Saturn)'],
        rulers: {0:'♂',1:'♀',2:'☿',3:'☽',4:'☉',5:'☿',6:'♀',7:'♂',8:'♃',9:'♄',10:'♄',11:'♃'},
        exaltations: {0:'☉',1:'☽',2:'☊',5:'☿',6:'♄',8:'☋',9:'♂',11:'♀'},
        detriments: {0:'♀',1:'♂',2:'♃',3:'♄',4:'♄',5:'♃',6:'♂',7:'♀',8:'☿',9:'☽',10:'☉',11:'☿'},
        falls: {2:'☋',5:'♀',6:'☉',8:'☊',9:'☽',11:'☿'},
        egyptianBounds: [[['♃',6],['♀',12],['☿',20],['♂',25],['♄',30]],[['♀',8],['☿',14],['♃',22],['♄',27],['♂',30]],[['☿',6],['♃',12],['♀',17],['♂',24],['♄',30]],[['♂',7],['♀',13],['☿',19],['♃',26],['♄',30]],[['♃',6],['♀',11],['♄',18],['☿',24],['♂',30]],[['☿',7],['♀',17],['♃',21],['♂',28],['♄',30]],[['♄',6],['☿',14],['♃',21],['♀',28],['♂',30]],[['♂',7],['♀',11],['☿',19],['♃',24],['♄',30]],[['♃',12],['♀',17],['☿',21],['♄',26],['♂',30]],[['♀',6],['☿',12],['♃',19],['♂',25],['♄',30]],[['♄',6],['☿',12],['♀',20],['♃',25],['♂',30]],[['♀',12],['♃',16],['☿',19],['♂',28],['♄',30]]],
        ptolemyBounds: [[['♃',6],['♀',14],['☿',21],['♂',26],['♄',30]],[['♀',8],['☿',15],['♃',22],['♄',26],['♂',30]],[['☿',7],['♃',14],['♀',21],['♄',25],['♂',30]],[['♂',6],['♃',13],['☿',20],['♀',27],['♄',30]],[['♃',6],['♀',13],['♄',19],['☿',25],['♂',30]],[['☿',7],['♀',13],['♃',18],['♄',24],['♂',30]],[['♄',6],['♀',11],['♃',19],['☿',24],['♂',30]],[['♂',6],['♃',14],['♀',21],['☿',27],['♄',30]],[['♃',8],['♀',14],['☿',19],['♄',25],['♂',30]],[['♀',6],['☿',12],['♃',19],['♂',25],['♄',30]],[['☿',7],['♀',13],['♃',20],['♂',25],['♄',30]],[['♀',8],['♃',14],['☿',20],['♂',26],['♄',30]]],
        chaldeanBounds: [[['♂',6],['☉',12],['♀',20],['☿',25],['♄',30]],[['♀',8],['☿',15],['☽',22],['♄',26],['♂',30]],[['☿',6],['♃',13],['♀',17],['♄',24],['♂',30]],[['♂',6],['♀',12],['☽',18],['♃',24],['♄',30]],[['♄',6],['☿',13],['♀',19],['♃',25],['♂',30]],[['☿',6],['♀',12],['♃',18],['♄',24],['♂',30]],[['♄',6],['♀',11],['♃',16],['☿',24],['♂',30]],[['♂',6],['♀',14],['☿',21],['♃',27],['♄',30]],[['♃',8],['♀',13],['☿',18],['♄',26],['♂',30]],[['♀',6],['☿',11],['♃',16],['♂',23],['♄',30]],[['☿',6],['♀',12],['♃',20],['♂',24],['♄',30]],[['♀',8],['♃',13],['☿',17],['♂',23],['♄',30]]]
    };

    let planets = [{symbol:'☉',name:'Sun',angle:120,color:'#FFD700'},{symbol:'☽',name:'Moon',angle:90,color:'#C0C0C0'},{symbol:'♂',name:'Mars',angle:0,color:'#FF4500'},{symbol:'♀',name:'Venus',angle:30,color:'#32CD32'},{symbol:'☿',name:'Mercury',angle:60,color:'#FFA500'},{symbol:'♃',name:'Jupiter',angle:240,color:'#4169E1'},{symbol:'♄',name:'Saturn',angle:270,color:'#8B4513'}];

    const keywords = {signs:{'Aries':['Cardinal Fire','Hot & Dry','Choleric','Masculine','Diurnal','Spring Equinox','Ram','Head & Face','Initiative','Commanding','Mars Domicile','Sun Exaltation','Eastern','Moveable','Bestial'],'Taurus':['Fixed Earth','Cold & Dry','Melancholic','Feminine','Nocturnal','Spring','Bull','Neck & Throat','Stability','Possessions','Venus Domicile','Moon Exaltation','Southern','Solid','Four-footed'],'Gemini':['Mutable Air','Hot & Moist','Sanguine','Masculine','Diurnal','Late Spring','Twins','Arms & Hands','Communication','Versatility','Mercury Domicile','North Node Exalt','Western','Bicorporeal','Human'],'Cancer':['Cardinal Water','Cold & Moist','Phlegmatic','Feminine','Nocturnal','Summer Solstice','Crab','Breast & Stomach','Home','Mother','Moon Domicile','Jupiter Traditional','Northern','Tropical','Mute'],'Leo':['Fixed Fire','Hot & Dry','Choleric','Masculine','Diurnal','Midsummer','Lion','Heart & Back','Royalty','Authority','Sun Domicile','No Exaltation','Eastern','Commanding','Bestial'],'Virgo':['Mutable Earth','Cold & Dry','Melancholic','Feminine','Nocturnal','Late Summer','Virgin','Belly & Intestines','Service','Analysis','Mercury Domicile','Mercury Exaltation','Southern','Barren','Human'],'Libra':['Cardinal Air','Hot & Moist','Sanguine','Masculine','Diurnal','Autumn Equinox','Scales','Kidneys & Lumbar','Balance','Justice','Venus Domicile','Saturn Exaltation','Western','Moveable','Human'],'Scorpio':['Fixed Water','Cold & Moist','Phlegmatic','Feminine','Nocturnal','Autumn','Scorpion','Genitals','Death','Transformation','Mars Domicile','South Node Exalt','Northern','Fruitful','Reptile'],'Sagittarius':['Mutable Fire','Hot & Dry','Choleric','Masculine','Diurnal','Late Autumn','Centaur','Thighs & Hips','Philosophy','Religion','Jupiter Domicile','No Exaltation','Eastern','Bicorporeal','Four-footed'],'Capricorn':['Cardinal Earth','Cold & Dry','Melancholic','Feminine','Nocturnal','Winter Solstice','Goat','Knees','Authority','Structure','Saturn Domicile','Mars Exaltation','Southern','Tropical','Four-footed'],'Aquarius':['Fixed Air','Hot & Moist','Sanguine','Masculine','Diurnal','Midwinter','Water-bearer','Calves & Ankles','Friendship','Groups','Saturn Domicile','No Exaltation','Western','Human','Rational'],'Pisces':['Mutable Water','Cold & Moist','Phlegmatic','Feminine','Nocturnal','Late Winter','Fishes','Feet','Compassion','Sacrifice','Jupiter Domicile','Venus Exaltation','Northern','Bicorporeal','Mute']},planets:{'Sun':['Greater Luminary','Hot & Dry','Choleric','Masculine','Gold','Leo Ruler','Aries Exalted','Father','King','Authority','Vitality','Honor','Government','Right Eye','Spirit'],'Moon':['Lesser Luminary','Cold & Moist','Phlegmatic','Feminine','Silver','Cancer Ruler','Taurus Exalted','Mother','Queen','Body','Fluctuation','Memory','Common People','Left Eye','Soul'],'Mercury':['Neutral Planet','Convertible','Convertible','Neutral','Quicksilver','Gemini/Virgo Ruler','Virgo Exalted','Messenger','Youth','Learning','Speech','Commerce','Writing','Siblings','Swift'],'Venus':['Lesser Benefic','Cold & Moist','Phlegmatic','Feminine','Copper','Taurus/Libra Ruler','Pisces Exalted','Love','Beauty','Pleasure','Women','Art','Music','Marriage','Harmony'],'Mars':['Lesser Malefic','Hot & Dry','Choleric','Masculine','Iron','Aries/Scorpio Ruler','Capricorn Exalted','War','Strife','Courage','Surgery','Iron','Soldiers','Cutting','Violence'],'Jupiter':['Greater Benefic','Hot & Moist','Sanguine','Masculine','Tin','Sagittarius/Pisces Ruler','Cancer Traditional','Wisdom','Religion','Fortune','Expansion','Law','Philosophy','Priests','Judges'],'Saturn':['Greater Malefic','Cold & Dry','Melancholic','Masculine','Lead','Capricorn/Aquarius Ruler','Libra Exalted','Time','Limitation','Discipline','Old Age','Hardship','Agriculture','Patience','Wisdom']},houses:{'1st':['Angular House','House of Life','Ascendant','Self','Body','Appearance','Vitality','Character','Native','Health','Temperament','Life Force','Beginning of Life','Personal Manner','Constitution'],'2nd':['Succedent House','Gate of Hades','Possessions','Moveable Goods','Money','Substance','Profit','Gain','Resources','Food','Clothing','Personal Property','Wealth','Material Security','Earnings'],'3rd':['Cadent House','House of Goddess','Siblings','Brethren','Short Journeys','Letters','Messages','Moon Joy','Neighbors','Reports','Communications','Local Travel','Religious Worship','Small Travels','Announcements'],'4th':['Angular House','Angle of Earth','Father','Parents','Ancestry','Land','Real Estate','End of Life','Grave','Hidden Treasure','Foundations','Inheritance from Father','Old Age','Private Affairs','Homeland'],'5th':['Succedent House','House of Good Fortune','Children','Offspring','Pregnancy','Venus Joy','Pleasure','Entertainment','Good Fortune','Gifts','Legacies','Recreation','Creative Works','Procreation','Joy'],'6th':['Cadent House','House of Bad Fortune','Illness','Sickness','Servants','Slaves','Small Animals','Mars Joy','Enemies','Work','Service','Bad Fortune','Injury','Laborers','Misfortune'],'7th':['Angular House','Angle of West','Marriage','Spouse','Partnerships','Open Enemies','Others','Legal Opponents','Contracts','War','Lawsuits','Public Relations','Competitors','Thieves','Fugitives'],'8th':['Succedent House','House of Death','Death','Wills','Legacies','Others Money','Saturn Joy','Inheritance','Debt','Taxes','Partners Resources','Fear','Anxiety','Transformation','Occult Sciences'],'9th':['Cadent House','House of God','Religion','Philosophy','Long Journeys','Foreign Lands','Sun Joy','Dreams','Visions','Higher Learning','Prophecy','Wisdom','Spiritual Matters','Foreign Affairs','Publishing'],'10th':['Angular House','House of Honor','Midheaven','Mother','Career','Reputation','Honor','Authority','Government','Fame','Public Standing','Achievement','Kingdom','Dignity','Social Position'],'11th':['Succedent House','House of Good Spirit','Friends','Hope','Good Fortune','Jupiter Joy','Benefactors','Allies','Good Daemon','Counselors','Trust','Praise','Acquisition','Assistants','Social Groups'],'12th':['Cadent House','House of Bad Spirit','Hidden Enemies','Secret Foes','Large Animals','Imprisonment','Exile','Sorrow','Self-Undoing','Bad Spirit','Affliction','Witchcraft','Secret Sorrows','Private Enemies','Confinement']}};

    // Performance-Optimized Math Utilities
    const Utils = {
        degToRad: deg => deg * Math.PI / 180,
        radToDeg: rad => rad * 180 / Math.PI,
        normalizeAngle: angle => ((angle % 360) + 360) % 360,
        getPlanetPos: (angle, planetSymbol, planet = null) => {
            if (document.getElementById('freeSymbolMovement')?.checked && planet?.freeX) {
                return {x: planet.freeX, y: planet.freeY};
            }
            if (FREE_SYMBOLS.includes(planetSymbol) && planet?.freeX) {
                return {x: planet.freeX, y: planet.freeY};
            }
            const rad = Utils.degToRad(180 - angle);
            const circleKey = PTOLEMAIC_CIRCLES[planetSymbol];
            const r = circleKey ? CONFIG.radii[circleKey] : CONFIG.radii.sun;
            return {x: CONFIG.center + Math.cos(rad) * r, y: CONFIG.center + Math.sin(rad) * r};
        },
        getAngleFromPos: (x, y) => Utils.normalizeAngle(180 - Utils.radToDeg(Math.atan2(y - CONFIG.center, x - CONFIG.center))),
        getSignFromAngle: angle => Math.floor(Utils.normalizeAngle(angle - state.zodiacOffset) / 30),
        getHouseFromAngle: angle => Math.floor(Utils.normalizeAngle(angle) / 30),
        getDignity: (planetSymbol, signIndex) => {
            if (ASTRO_DATA.rulers[signIndex] === planetSymbol) return 'Domicile';
            if (ASTRO_DATA.exaltations[signIndex] === planetSymbol) return 'Exaltation';
            if (ASTRO_DATA.detriments[signIndex] === planetSymbol) return 'Detriment';
            if (ASTRO_DATA.falls[signIndex] === planetSymbol) return 'Fall';
            return 'Peregrine';
        },
        getDignityColor: dignity => ({Domicile:'#00FF00',Exaltation:'#FFD700',Detriment:'#FF6666',Fall:'#FF4444',Peregrine:'#CCCCCC'})[dignity],
        getMousePos: e => {
            const rect = CONFIG.canvas.getBoundingClientRect();
            const touch = e.touches?.[0] || e.changedTouches?.[0] || e;
            return {
                x: (touch.clientX - rect.left) * (CONFIG.canvas.width / rect.width),
                y: (touch.clientY - rect.top) * (CONFIG.canvas.height / rect.height)
            };
        }
    };

    // Optimized Hit Detection System
    const HitDetection = {
        getPlanetAt: (x, y) => {
            if (state.hidePlanets) return null;
            for (let i = planets.length - 1; i >= 0; i--) {
                const pos = Utils.getPlanetPos(planets[i].angle, planets[i].symbol, planets[i]);
                if (Math.hypot(x - pos.x, y - pos.y) < 25) return {planet: planets[i], index: i};
            }
            return null;
        },
        getSignAt: (x, y) => {
            if (state.hideZodiac) return null;
            const distance = Math.hypot(x - CONFIG.center, y - CONFIG.center);
            return (distance >= CONFIG.radii.decan && distance <= CONFIG.radii.outer) 
                ? Utils.getSignFromAngle(Utils.getAngleFromPos(x, y)) : null;
        },
        getHouseAt: (x, y) => {
            const distance = Math.hypot(x - CONFIG.center, y - CONFIG.center);
            return distance <= CONFIG.radii.inner ? Utils.getHouseFromAngle(Utils.getAngleFromPos(x, y)) : null;
        },
        isInZodiacRing: (x, y) => {
            if (state.hideZodiac) return false;
            const distance = Math.hypot(x - CONFIG.center, y - CONFIG.center);
            return distance >= CONFIG.radii.decan && distance <= CONFIG.radii.outer;
        },
        getAngleControlAt: (x, y) => {
            if (!document.getElementById('showAngles')?.checked) return null;
            const controls = Renderer.getAngleControlPoints();
            for (const [name, pos] of Object.entries(controls)) {
                if (Math.hypot(x - pos.x, y - pos.y) < 20) return name;
            }
            return null;
        }
    };

    // High-Performance Drawing System
    const DrawingSystem = {
        getDistanceToLine: (px, py, x1, y1, x2, y2) => {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D, lenSq = C * C + D * D;
            if (lenSq === 0) return Math.hypot(A, B);
            const param = Math.max(0, Math.min(1, dot / lenSq));
            return Math.hypot(px - (x1 + param * C), py - (y1 + param * D));
        },
        eraseAtPoint: (x, y, eraserSize) => {
            // Mobile optimization: Larger effective eraser size and more aggressive erasing
            const baseSize = CONFIG.isMobile ? Math.max(eraserSize * 8, 20) : Math.max(eraserSize * 4, 10);
            const effectiveRadius = baseSize / 2;
            const radiusSquared = effectiveRadius * effectiveRadius; 
            const pathsToRemove = [], newPathsToAdd = [];
            
            state.drawingPaths.forEach((path, pathIndex) => {
                if (path[0]?.type === 'line') {
                    if (path.length >= 2) {
                        const lineDistance = DrawingSystem.getDistanceToLine(x, y, path[0].x, path[0].y, path[path.length - 1].x, path[path.length - 1].y);
                        // Consider line thickness for accurate erasing
                        const lineThickness = path[0].size || 2;
                        if (lineDistance <= effectiveRadius + lineThickness) {
                            pathsToRemove.push(pathIndex);
                        }
                    }
                } else {
                    // Enhanced path erasing with mobile-friendly segmentation
                    const segments = [];
                    let currentSegment = [];
                    let erased = false;
                    
                    path.forEach(point => {
                        const distanceSquared = (x - point.x) * (x - point.x) + (y - point.y) * (y - point.y);
                        const brushThickness = point.size || 2;
                        const totalRadiusSquared = (effectiveRadius + brushThickness) * (effectiveRadius + brushThickness);
                        if (distanceSquared > totalRadiusSquared) {
                            currentSegment.push(point);
                        } else {
                            erased = true;
                            if (currentSegment.length > (CONFIG.isMobile ? 2 : 3)) {
                                segments.push([...currentSegment]);
                            }
                            currentSegment = [];
                        }
                    });
                    
                    if (currentSegment.length > (CONFIG.isMobile ? 2 : 3)) {
                        segments.push(currentSegment);
                    }
                    
                    if (erased) {
                        pathsToRemove.push(pathIndex);
                        if (segments.length > 0) {
                            newPathsToAdd.push(...segments);
                        }
                    }
                }
            });
            // Batch removal for performance
            pathsToRemove.reverse().forEach(index => state.drawingPaths.splice(index, 1));
            state.drawingPaths.push(...newPathsToAdd);
        },
        drawPaths: () => {
            const ctx = CONFIG.ctx;
            state.drawingPaths.forEach(path => {
                if (path.length < 2) return;
                ctx.strokeStyle = path[0].color;
                ctx.lineWidth = path[0].size;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                if (path[0].type === 'line') {
                    ctx.moveTo(path[0].x, path[0].y);
                    ctx.lineTo(path[path.length - 1].x, path[path.length - 1].y);
                } else {
                    ctx.moveTo(path[0].x, path[0].y);
                    for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();
            });
        },
        updateEraserIndicator: (x, y) => {
            const indicator = document.getElementById('eraserIndicator');
            const tool = document.getElementById('drawTool')?.value;
            
            if (tool === 'eraser' && state.mode === 'draw') {
                const rect = CONFIG.canvas.getBoundingClientRect();
                const eraserSize = parseInt(document.getElementById('drawSize')?.value || 10);
                
                // Mobile-optimized size calculation
                const realEraserSize = CONFIG.isMobile ? Math.max(eraserSize * 8, 20) : Math.max(eraserSize * 4, 10);
                const effectiveSize = realEraserSize;
                
                // High-precision coordinate conversion
                const scaleX = rect.width / CONFIG.canvas.width;
                const scaleY = rect.height / CONFIG.canvas.height;
                const screenX = rect.left + window.scrollX + (x * scaleX);
                const screenY = rect.top + window.scrollY + (y * scaleY);
                
                // Mobile-enhanced indicator styling
                const borderStyle = CONFIG.isMobile ? '3px solid #fff' : '2px dashed #fff';
                const opacity = CONFIG.isMobile ? '0.8' : '1';
                
                indicator.style.cssText = `
                    position: absolute;
                    left: ${screenX - effectiveSize / 2}px;
                    top: ${screenY - effectiveSize / 2}px;
                    width: ${effectiveSize}px;
                    height: ${effectiveSize}px;
                    border: ${borderStyle};
                    border-radius: 50%;
                    pointer-events: none;
                    display: block;
                    opacity: ${opacity};
                    z-index: 1000;
                    box-shadow: ${CONFIG.isMobile ? '0 0 10px rgba(255,255,255,0.3)' : 'none'};
                `;
            } else {
                indicator.style.display = 'none';
            }
        }
    };

    // Professional Rendering Engine
    const Renderer = {
        getAngleControlPoints: () => {
            const ascAngle = Utils.degToRad(180 - state.ascendantOffset);
            const mcAngle = Utils.degToRad(180 - state.ascendantOffset - 270);
            const controlRadius = CONFIG.radii.outer + 35;
            return {
                asc: {x: CONFIG.center + Math.cos(ascAngle) * controlRadius, y: CONFIG.center + Math.sin(ascAngle) * controlRadius},
                dsc: {x: CONFIG.center - Math.cos(ascAngle) * controlRadius, y: CONFIG.center - Math.sin(ascAngle) * controlRadius},
                mc: {x: CONFIG.center + Math.cos(mcAngle) * controlRadius, y: CONFIG.center + Math.sin(mcAngle) * controlRadius},
                ic: {x: CONFIG.center - Math.cos(mcAngle) * controlRadius, y: CONFIG.center - Math.sin(mcAngle) * controlRadius}
            };
        },
        drawBoundsSystem: (boundsData, outerRadius, innerRadius, color) => {
            const ctx = CONFIG.ctx;
            for (let i = 0; i < 12; i++) {
                const bounds = boundsData[i];
                let prevDegree = 0;
                bounds.forEach(([planet, degree]) => {
                    const startAngle = Utils.degToRad(180 - (i * 30 + prevDegree) - state.zodiacOffset);
                    const endAngle = Utils.degToRad(180 - (i * 30 + degree) - state.zodiacOffset);
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(CONFIG.center, CONFIG.center, outerRadius, startAngle, endAngle);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(CONFIG.center + Math.cos(endAngle) * innerRadius, CONFIG.center + Math.sin(endAngle) * innerRadius);
                    ctx.lineTo(CONFIG.center + Math.cos(endAngle) * outerRadius, CONFIG.center + Math.sin(endAngle) * outerRadius);
                    ctx.stroke();
                    
                    const midAngle = (startAngle + endAngle) / 2;
                    const textRadius = (outerRadius + innerRadius) / 2;
                    
                    ctx.fillStyle = color;
                    ctx.font = 'bold 25px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(planet, CONFIG.center + Math.cos(midAngle) * textRadius, CONFIG.center + Math.sin(midAngle) * textRadius);
                    prevDegree = degree;
                });
            }
        },
        drawChart: () => {
            const ctx = CONFIG.ctx;
            ctx.clearRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            
            // Base rings
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            if (!state.hideZodiac) {
                [CONFIG.radii.outer, CONFIG.radii.decan].forEach(r => {
                    ctx.beginPath();
                    ctx.arc(CONFIG.center, CONFIG.center, r, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }
            ctx.beginPath();
            ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii.inner, 0, Math.PI * 2);
            ctx.stroke();

            // Central aspect circle
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii.aspect, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii.aspect, 0, Math.PI * 2);
            ctx.stroke();

            DrawingSystem.drawPaths();
            
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii.aspect, 0, Math.PI * 2);
            ctx.stroke();

            const planetaryCircles = [
                {key: 'saturn', color: '#8B4513', show: 'showSaturnCircle', label: '♄'},
                {key: 'jupiter', color: '#4169E1', show: 'showJupiterCircle', label: '♃'},
                {key: 'mars', color: '#FF4500', show: 'showMarsCircle', label: '♂'},
                {key: 'sun', color: '#FFD700', show: 'showSunCircle', label: '☉'},
                {key: 'venus', color: '#32CD32', show: 'showVenusCircle', label: '♀'},
                {key: 'mercury', color: '#FFA500', show: 'showMercuryCircle', label: '☿'},
                {key: 'moon', color: '#C0C0C0', show: 'showMoonCircle', label: '☽'}
            ];

        planetaryCircles.forEach(circle => {
            const checkbox = document.getElementById(circle.show);
            if (checkbox && checkbox.checked) {
                ctx.strokeStyle = circle.color;
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]); // Dashed line for planetary circles
                ctx.beginPath();
                ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii[circle.key], 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]); // Reset line dash
                
                // Optional: Add circle labels
                ctx.fillStyle = circle.color;
                ctx.font = CONFIG.isMobile ? '12px Arial' : '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(circle.label, CONFIG.center + CONFIG.radii[circle.key] + 15, CONFIG.center);
            }
        });
            
            // Bounds systems
            const checkElement = (id) => document.getElementById(id)?.checked;
            if (checkElement('showEgyptianBounds')) {
                ctx.strokeStyle = CONFIG.colors.dim;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii.egyptian, 0, Math.PI * 2);
                ctx.stroke();
                Renderer.drawBoundsSystem(ASTRO_DATA.egyptianBounds, CONFIG.radii.outer, CONFIG.radii.egyptian, '#8B4513');
            }
            if (checkElement('showPtolemyBounds')) {
                ctx.strokeStyle = CONFIG.colors.dim;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii.ptolemy, 0, Math.PI * 2);
                ctx.stroke();
                Renderer.drawBoundsSystem(ASTRO_DATA.ptolemyBounds, CONFIG.radii.egyptian, CONFIG.radii.ptolemy, '#4682B4');
            }
            if (checkElement('showChaldeanBounds')) {
                ctx.strokeStyle = CONFIG.colors.dim;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(CONFIG.center, CONFIG.center, CONFIG.radii.chaldean, 0, Math.PI * 2);
                ctx.stroke();
                Renderer.drawBoundsSystem(ASTRO_DATA.chaldeanBounds, CONFIG.radii.ptolemy, CONFIG.radii.chaldean, '#6A5ACD');
            }
            
            // Angles
            if (checkElement('showAngles')) {
                const controls = Renderer.getAngleControlPoints();
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(controls.asc.x, controls.asc.y);
                ctx.lineTo(controls.dsc.x, controls.dsc.y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(controls.mc.x, controls.mc.y);
                ctx.lineTo(controls.ic.x, controls.ic.y);
                ctx.stroke();
                
                ctx.fillStyle = '#FFD700';
                Object.values(controls).forEach(control => {
                    ctx.beginPath();
                    ctx.arc(control.x, control.y, 12, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                const getSignInfo = (offset) => {
                    const signIndex = Utils.getSignFromAngle((state.ascendantOffset + offset) % 360);
                    const degree = Math.floor(Utils.normalizeAngle((state.ascendantOffset + offset) - state.zodiacOffset) % 30);
                    return {signIndex, degree};
                };
                
                const asc = getSignInfo(0), dsc = getSignInfo(180), mc = getSignInfo(270), ic = getSignInfo(90);
                
                ctx.font = CONFIG.isMobile ? '10px Arial' : 'bold 12px Arial';
                ctx.textAlign = 'center';
                const labelOffset = CONFIG.isMobile ? 20 : 30;
                ctx.fillText(`ASC - ${ASTRO_DATA.signNames[asc.signIndex]} ${asc.degree}°`, controls.asc.x, controls.asc.y + labelOffset);
                ctx.fillText(`DSC - ${ASTRO_DATA.signNames[dsc.signIndex]} ${dsc.degree}°`, controls.dsc.x, controls.dsc.y + labelOffset);
                ctx.fillText(`MC - ${ASTRO_DATA.signNames[mc.signIndex]} ${mc.degree}°`, controls.mc.x, controls.mc.y - labelOffset);
                ctx.fillText(`IC - ${ASTRO_DATA.signNames[ic.signIndex]} ${ic.degree}°`, controls.ic.x, controls.ic.y + labelOffset);

                ctx.fillText(`East`, controls.asc.x, controls.asc.y + labelOffset + 15);
                ctx.fillText(`West`, controls.dsc.x, controls.dsc.y + labelOffset + 15);
                ctx.fillText(`South`, controls.mc.x, controls.mc.y - labelOffset - 15);
                ctx.fillText(`North`, controls.ic.x, controls.ic.y + labelOffset + 15);
            }
            
            // Zodiac signs
            if (!state.hideZodiac) {
                for (let i = 0; i < 12; i++) {
                    const startAngle = Utils.degToRad(180 - (i * 30) - state.zodiacOffset);
                    const midAngle = Utils.degToRad(180 - (i * 30 + 15) - state.zodiacOffset);
                    const isSelected = state.selectedSign === i;
                    
                    ctx.strokeStyle = state.mode === 'zodiac' ? (isSelected ? '#FF6666' : '#888') : '#444';
                    ctx.lineWidth = state.mode === 'zodiac' ? (isSelected ? 3 : 2) : 1;
                    ctx.beginPath();
                    ctx.moveTo(CONFIG.center + Math.cos(startAngle) * CONFIG.radii.decan, CONFIG.center + Math.sin(startAngle) * CONFIG.radii.decan);
                    ctx.lineTo(CONFIG.center + Math.cos(startAngle) * CONFIG.radii.outer, CONFIG.center + Math.sin(startAngle) * CONFIG.radii.outer);
                    ctx.stroke();
                    
                    const signR = (CONFIG.radii.decan + CONFIG.radii.outer) / 2;
                    const x = CONFIG.center + Math.cos(midAngle) * signR;
                    const y = CONFIG.center + Math.sin(midAngle) * signR;
                    
                    ctx.fillStyle = isSelected ? '#FF6666' : '#FFD700';
                    ctx.font = CONFIG.isMobile ? '22px Arial' : 'bold 28px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(ASTRO_DATA.signs[i], x, y);
                    
                    let yOffset = CONFIG.isMobile ? 15 : 20;
                    if (checkElement('showDignities')) {
                        ctx.font = CONFIG.isMobile ? '14px Arial' : '18px Arial';
                        ctx.fillStyle = '#ccc';
                        let dignityText = '';
                        if (ASTRO_DATA.rulers[i]) dignityText += '♦' + ASTRO_DATA.rulers[i];
                        if (ASTRO_DATA.exaltations[i]) dignityText += ' ▲' + ASTRO_DATA.exaltations[i];
                        if (dignityText) {
                            ctx.fillText(dignityText, x, y + yOffset);
                            yOffset += 12;
                        }
                    }
                    
                    const infoChecks = [
                        [checkElement('showQualities'), ASTRO_DATA.qualities[i]],
                        [checkElement('showElements'), ASTRO_DATA.elements[i]],
                        [checkElement('showSeason'), ASTRO_DATA.seasons[i]],
                        [checkElement('showSolarIngress'), ASTRO_DATA.solarIngress[i]],
                        [checkElement('showFigureSigns'), ASTRO_DATA.figureSigns[i]],
                        [checkElement('showFertileBarren'), ASTRO_DATA.fertileBarren[i]],
                        [checkElement('showSignTemps'), ASTRO_DATA.signTemps[i]],
                        [checkElement('showSignGenders'), ASTRO_DATA.signGenders[i]]
                    ];
                    
                    const infoText = infoChecks.filter(c => c[0]).map(c => c[1]).join('|');
                    if (infoText) {
                        ctx.font = CONFIG.isMobile ? '9px Arial' : '12px Arial';
                        ctx.fillStyle = '#ccc';
                        ctx.fillText(infoText, x, y + yOffset);
                    }
                }
                
                // Decans
                if (checkElement('showDecans')) {
                    for (let i = 0; i < 12; i++) {
                        for (let d = 0; d < 3; d++) {
                            const decanAngle = Utils.degToRad(180 - (i * 30 + d * 10) - state.zodiacOffset);
                            ctx.strokeStyle = '#666';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(CONFIG.center + Math.cos(decanAngle) * CONFIG.radii.inner, CONFIG.center + Math.sin(decanAngle) * CONFIG.radii.inner);
                            ctx.lineTo(CONFIG.center + Math.cos(decanAngle) * CONFIG.radii.decan, CONFIG.center + Math.sin(decanAngle) * CONFIG.radii.decan);
                            ctx.stroke();
                            
                            const decanMidAngle = Utils.degToRad(180 - (i * 30 + d * 10 + 5) - state.zodiacOffset);
                            const decanRadius = (CONFIG.radii.inner + CONFIG.radii.decan) / 2;
                            const dx = CONFIG.center + Math.cos(decanMidAngle) * decanRadius;
                            const dy = CONFIG.center + Math.sin(decanMidAngle) * decanRadius;
                            
                            ctx.fillStyle = '#87CEEB';
                            ctx.font = CONFIG.isMobile ? '16px Arial' : 'bold 20px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(ASTRO_DATA.decans[i][d], dx, dy);
                        }
                    }
                }
            }
            
            // Houses
            for (let i = 0; i < 12; i++) {
                const angle = Utils.degToRad(180 - (i * 30));
                ctx.strokeStyle = state.mode === 'houses' ? '#FF6666' : '#444';
                ctx.lineWidth = state.mode === 'houses' ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(CONFIG.center + Math.cos(angle) * CONFIG.radii.aspect, CONFIG.center + Math.sin(angle) * CONFIG.radii.aspect);
                ctx.lineTo(CONFIG.center + Math.cos(angle) * CONFIG.radii.inner, CONFIG.center + Math.sin(angle) * CONFIG.radii.inner);
                ctx.stroke();
                
                const houseR = (CONFIG.radii.aspect + CONFIG.radii.inner) / 2;
                const midAngle = Utils.degToRad(180 - (i * 30 + 15));
                const x = CONFIG.center + Math.cos(midAngle) * houseR;
                const y = CONFIG.center + Math.sin(midAngle) * houseR;
                
                ctx.fillStyle = state.mode === 'houses' ? '#FF6666' : '#888';
                ctx.font = CONFIG.isMobile ? '14px Arial' : 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((i + 1).toString(), x, y);
                
                let yOffset = CONFIG.isMobile ? 12 : 15;
                const houseChecks = [
                    [checkElement('showHouseSect'), ASTRO_DATA.houseSect[i], '#ff9999'],
                    [checkElement('showHouseTypes'), ASTRO_DATA.houseTypes[i], '#90ee90'],
                    [checkElement('showhouseJoy'), ASTRO_DATA.houseJoy[i], '#eeee90'],
                    [checkElement('showDirections'), ASTRO_DATA.houseDirections[i], '#87ceeb']
                ];
                
                houseChecks.forEach(([show, text, color]) => {
                    if (show && text) {
                        ctx.font = CONFIG.isMobile ? '11px Arial' : '14px Arial';
                        ctx.fillStyle = color;
                        ctx.fillText(text, x, y + yOffset);
                        yOffset += 10;
                    }
                });
            }
            
            // Planets
            if (!state.hidePlanets) {
                planets.forEach((planet, index) => {
                    const pos = Utils.getPlanetPos(planet.angle, planet.symbol, planet);
                    const isSelected = state.selectedPlanet === index;
                    const signIndex = Utils.getSignFromAngle(planet.angle);
                    const dignity = Utils.getDignity(planet.symbol, signIndex);
                    const showCircles = document.getElementById('showPlanetCircles')?.checked !== false;
                    
                    if (planet.showCircle !== false && showCircles) {
                    if (checkElement('showDignities')) {
                        ctx.strokeStyle = Utils.getDignityColor(dignity);
                        ctx.lineWidth = 4;
                    } else {
                        ctx.strokeStyle = state.mode === 'planets' ? (isSelected ? '#FF6666' : '#FFF') : '#666';
                        ctx.lineWidth = state.mode === 'planets' ? (isSelected ? 4 : 3) : 2;
                    }

                    ctx.fillStyle = planet.color;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, CONFIG.isMobile ? 20 : 20, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                                }
                    ctx.fillStyle = showCircles ? (planet.textColor || '#000') : planet.color;
                    ctx.font = CONFIG.isMobile ? '18px Arial' : 'bold 24px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(planet.symbol, pos.x, pos.y);
                    
                    if (state.mode === 'planets') {
                        ctx.fillStyle = '#FF4444';
                        ctx.font = CONFIG.isMobile ? '12px Arial' : 'bold 16px Arial';
                        ctx.fillText('×', pos.x + 12, pos.y - 12);
                    }
                    
                    let yOffset = CONFIG.isMobile ? 20 : 25;
                    if (checkElement('showDignities')) {
                        ctx.fillStyle = Utils.getDignityColor(dignity);
                        ctx.font = CONFIG.isMobile ? '10px Arial' : 'bold 12px Arial';
                        ctx.fillText(dignity, pos.x, pos.y + yOffset);
                        yOffset += 12;
                    }
                    
                    if (checkElement('showInfo')) {
                        const houseIndex = Utils.getHouseFromAngle(planet.angle);
                        const degree = Math.floor(Utils.normalizeAngle(planet.angle - state.zodiacOffset) % 30);
                        ctx.fillStyle = '#FFF';
                        ctx.font = CONFIG.isMobile ? '10px Arial' : '12px Arial';
                        const info = state.mode === 'houses' ? `H${houseIndex + 1}` : `${ASTRO_DATA.signNames[signIndex]} ${degree}°`;
                        ctx.fillText(info, pos.x, pos.y + yOffset);
                        yOffset += 10;
                    }
                    
                    const planetChecks = [
                        [checkElement('showPlanetTemps'), ASTRO_DATA.planetTemps[planet.symbol]],
                        [checkElement('showPlanetSect'), ASTRO_DATA.planetSect[planet.symbol]],
                        [checkElement('showBeneficMaleficPlanets'), ASTRO_DATA.beneficMaleficPlanets[planet.symbol]],
                        [checkElement('showPlanetGender'), ASTRO_DATA.planetGender[planet.symbol]]
                    ];
                    
                    const planetText = planetChecks.filter(c => c[0] && c[1]).map(c => c[1]).join('|');
                    if (planetText) {
                        ctx.fillStyle = '#CCC';
                        ctx.font = CONFIG.isMobile ? '9px Arial' : '11px Arial';
                        ctx.fillText(planetText, pos.x, pos.y + yOffset);
                    }
                });
            }
        }
    };

    // User Interface Controller
    const UI = {
        showKeywords: (type, name) => {
            const panel = document.getElementById('keywordsPanel');
            const keywordList = keywords[type + 's']?.[name];
            if (keywordList && panel) {
                panel.innerHTML = `<h3>${name}</h3><ul>${keywordList.map(k => `<li>• ${k}</li>`).join('')}</ul>`;
            }
        },
        setMode: newMode => {
            state.mode = newMode;
            state.selectedSign = null;
            state.selectedPlanet = null;
            document.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(newMode + 'Btn')?.classList.add('active');
            
            const planetSelect = document.getElementById('planetSelect');
            const drawControls = document.getElementById('drawControls');
            if (planetSelect) planetSelect.style.display = newMode === 'planets' ? 'inline' : 'none';
            if (drawControls) drawControls.style.display = newMode === 'draw' ? 'block' : 'none';
            
            const tool = document.getElementById('drawTool')?.value || 'pencil';
            CONFIG.canvas.style.cursor = newMode === 'draw' ? (tool === 'eraser' ? 'none' : 'crosshair') : 'default';
            if (newMode !== 'draw') document.getElementById('eraserIndicator').style.display = 'none';
            UI.updateInfo();
            Renderer.drawChart();
        },
        updateInfo: text => {
            const info = document.getElementById('info');
            if (!info) return;
            if (text) {
                info.innerHTML = text;
                return;
            }
            const messages = {
                zodiac: 'Click sign to select, rotate with arrows or drag • Click for keywords',
                houses: 'Drag planets to see houses • Click for keywords',
                planets: 'Click planet to select, move with arrows or drag • Click × to delete',
                draw: 'Draw on chart • Use pencil/line/eraser tools • Press P/L/E/C for tools'
            };
            info.textContent = messages[state.mode] || '';
        },
        clearDrawing: () => {
            Object.assign(state, {drawingPaths: [], currentPath: [], lineStartPoint: null, isDrawing: false, isErasing: false});
            document.getElementById('eraserIndicator').style.display = 'none';
            Renderer.drawChart();
        },
        resetChart: () => {
            Object.assign(state, {
                zodiacOffset: 0, ascendantOffset: 0, selectedSign: null, selectedPlanet: null,
                drawingPaths: [], currentPath: [], lineStartPoint: null, isDrawing: false, isErasing: false,
                isDragging: false, dragTarget: null, hideZodiac: false, hidePlanets: false
            });
            document.getElementById('eraserIndicator').style.display = 'none';
            const hideZodiac = document.getElementById('hideZodiac');
            const hidePlanets = document.getElementById('hidePlanets');
            if (hideZodiac) hideZodiac.checked = false;
            if (hidePlanets) hidePlanets.checked = false;
            
            planets = [
                {symbol:'☉',name:'Sun',angle:120,color:'#FFD700'},
                {symbol:'☽',name:'Moon',angle:90,color:'#C0C0C0'},
                {symbol:'♂',name:'Mars',angle:0,color:'#FF4500'},
                {symbol:'♀',name:'Venus',angle:30,color:'#32CD32'},
                {symbol:'☿',name:'Mercury',angle:60,color:'#FFA500'},
                {symbol:'♃',name:'Jupiter',angle:240,color:'#4169E1'},
                {symbol:'♄',name:'Saturn',angle:270,color:'#8B4513'}
            ];
            UI.setMode('zodiac');
            UI.updateInfo('Chart reset');
            Renderer.drawChart();
        }
    };

    // Unified Event Handler System
    const Events = {
        handlePointerEvent: (e, action) => {
            e.preventDefault();
            const pos = Utils.getMousePos(e);
            if (action === 'start') Events.handlePointerStart(pos);
            else if (action === 'move') Events.handlePointerMove(pos);
            else if (action === 'end') Events.handlePointerEnd();
        },
        
        handleClick: e => {
            if (state.mode === 'draw' || state.isDragging) return;
            const pos = Utils.getMousePos(e);
            const planetData = HitDetection.getPlanetAt(pos.x, pos.y);
            const signIndex = HitDetection.getSignAt(pos.x, pos.y);
            const houseIndex = HitDetection.getHouseAt(pos.x, pos.y);
            
            if (planetData) {
                if (state.mode === 'planets') {
                    state.selectedPlanet = planetData.index;
                    Renderer.drawChart();
                }
                UI.showKeywords('planet', planetData.planet.name);
            } else if (signIndex !== null) {
                if (state.mode === 'zodiac') {
                    state.selectedSign = signIndex;
                    Renderer.drawChart();
                }
                UI.showKeywords('sign', ASTRO_DATA.signNames[signIndex]);
            } else if (houseIndex !== null) {
                const houseNum = houseIndex + 1;
                const ordinal = houseNum === 1 ? 'st' : houseNum === 2 ? 'nd' : houseNum === 3 ? 'rd' : 'th';
                UI.showKeywords('house', houseNum + ordinal);
            }
        },
        
        handlePointerStart: pos => {
            if (state.mode === 'draw') {
                const tool = document.getElementById('drawTool')?.value || 'pencil';
                const color = document.getElementById('drawColor')?.value || '#ffffff';
                const size = parseInt(document.getElementById('drawSize')?.value || 3);
                
                if (tool === 'eraser') {
                    state.isErasing = true;
                    DrawingSystem.eraseAtPoint(pos.x, pos.y, size * 2);
                    Renderer.drawChart();
                } else if (tool === 'line') {
                    if (!state.lineStartPoint) {
                        state.lineStartPoint = {x: pos.x, y: pos.y, color, size, type: 'line'};
                    } else {
                        state.drawingPaths.push([state.lineStartPoint, {x: pos.x, y: pos.y, color, size, type: 'line'}]);
                        state.lineStartPoint = null;
                        Renderer.drawChart();
                    }
                } else {
                    state.isDrawing = true;
                    state.currentPath = [{x: pos.x, y: pos.y, color, size, type: 'pencil'}];
                }
                return;
            }
            
            const angleControl = HitDetection.getAngleControlAt(pos.x, pos.y);
            if (angleControl) {
                state.isDragging = true;
                state.dragTarget = 'angle-control';
                state.dragAngleControl = angleControl;
                return;
            }
            
            const planetData = HitDetection.getPlanetAt(pos.x, pos.y);
            if (planetData) {
                const planetPos = Utils.getPlanetPos(planetData.planet.angle, planetData.planet.symbol, planetData.planet);
                if (state.mode === 'planets' && pos.x > planetPos.x + 8 && pos.y < planetPos.y - 8) {
                    planets.splice(planetData.index, 1);
                    if (state.selectedPlanet === planetData.index) state.selectedPlanet = null;
                    else if (state.selectedPlanet > planetData.index) state.selectedPlanet--;
                    Renderer.drawChart();
                    UI.updateInfo('Planet deleted');
                    return;
                }
                state.isDragging = true;
                state.dragTarget = planetData.planet;
                if (state.mode === 'planets') state.selectedPlanet = planetData.index;
            } else if (state.mode === 'zodiac' && HitDetection.isInZodiacRing(pos.x, pos.y)) {
                state.isDragging = true;
                state.dragTarget = 'zodiac';
                state.lastZodiacAngle = Utils.getAngleFromPos(pos.x, pos.y);
            }
        },
        
        handlePointerMove: pos => {
            if (state.mode === 'draw') {
                const tool = document.getElementById('drawTool')?.value || 'pencil';
                const color = document.getElementById('drawColor')?.value || '#ffffff';
                const size = parseInt(document.getElementById('drawSize')?.value || 3);
                
                DrawingSystem.updateEraserIndicator(pos.x, pos.y);
                
                if (tool === 'eraser' && state.isErasing) {
                    DrawingSystem.eraseAtPoint(pos.x, pos.y, size * 2);
                    Renderer.drawChart();
                } else if (tool === 'pencil' && state.isDrawing && state.currentPath.length > 0) {
                    state.currentPath.push({x: pos.x, y: pos.y, color, size, type: 'pencil'});
                    if (state.currentPath.length > 1) {
                        const ctx = CONFIG.ctx;
                        ctx.strokeStyle = color;
                        ctx.lineWidth = size;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        ctx.beginPath();
                        const prev = state.currentPath[state.currentPath.length - 2];
                        const curr = state.currentPath[state.currentPath.length - 1];
                        ctx.moveTo(prev.x, prev.y);
                        ctx.lineTo(curr.x, curr.y);
                        ctx.stroke();
                    }
                } else if (tool === 'line' && state.lineStartPoint) {
                    Renderer.drawChart();
                    const ctx = CONFIG.ctx;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = size;
                    ctx.lineCap = 'round';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(state.lineStartPoint.x, state.lineStartPoint.y);
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                return;
            }
            
            if (!state.isDragging || !state.dragTarget) return;
            
            if (state.dragTarget === 'zodiac') {
                const currentAngle = Utils.getAngleFromPos(pos.x, pos.y);
                const deltaAngle = currentAngle - state.lastZodiacAngle;
                state.zodiacOffset = Utils.normalizeAngle(state.zodiacOffset + deltaAngle);
                state.lastZodiacAngle = currentAngle;
                Renderer.drawChart();
            } else if (state.dragTarget === 'angle-control') {
                state.ascendantOffset = Utils.getAngleFromPos(pos.x, pos.y);
                
                // Show ASC degrees only when dragging angle controls
                if (state.dragAngleControl === 'asc') {
                    const ascSignIndex = Utils.getSignFromAngle(state.ascendantOffset);
                    const ascDegree = Math.floor(Utils.normalizeAngle(state.ascendantOffset - state.zodiacOffset) % 30);
                    UI.updateInfo(`<strong>ASC:</strong> ${ASTRO_DATA.signNames[ascSignIndex]} ${ascDegree}°`);
                }
                Renderer.drawChart();
            } else {
                const isFreeMovement = document.getElementById('freeSymbolMovement')?.checked || FREE_SYMBOLS.includes(state.dragTarget.symbol);
                
                if (isFreeMovement) {
                    state.dragTarget.freeX = pos.x;
                    state.dragTarget.freeY = pos.y;
                    // 🔧 FIX: Always update angle so info shows correctly
                    state.dragTarget.angle = Utils.getAngleFromPos(pos.x, pos.y);
                } else {
                    state.dragTarget.angle = Utils.getAngleFromPos(pos.x, pos.y);
                }
                const signIndex = Utils.getSignFromAngle(state.dragTarget.angle);
                const houseIndex = Utils.getHouseFromAngle(state.dragTarget.angle);
                const degree = Math.floor(Utils.normalizeAngle(state.dragTarget.angle - state.zodiacOffset) % 30);
                
                if (state.mode === 'zodiac') {
                    const dignity = Utils.getDignity(state.dragTarget.symbol, signIndex);
                    const color = Utils.getDignityColor(dignity);
                    UI.updateInfo(`<strong>${state.dragTarget.name}</strong>: ${ASTRO_DATA.signNames[signIndex]} ${degree}° &nbsp; | &nbsp; <span style="color: ${color}">${dignity}</span>`);
                } else if (state.mode === 'houses') {
                    UI.updateInfo(`<strong>${state.dragTarget.name}</strong>: ${ASTRO_DATA.houseNames[houseIndex]}`);
                }
                Renderer.drawChart();
            }
        },
        
        handlePointerEnd: () => {
            if (state.mode === 'draw') {
                if (state.isDrawing && state.currentPath.length > 0) {
                    state.drawingPaths.push([...state.currentPath]);
                    state.currentPath = [];
                }
                state.isDrawing = false;
                state.isErasing = false;
            }
            state.isDragging = false;
            state.dragTarget = null;
            state.dragAngleControl = null;
            UI.updateInfo();
        },
        
        handleKeyDown: e => {
            const keyMap = {
                'r': UI.resetChart,
                'd': () => toggleCheckbox('showInfo'),
                'g': () => toggleCheckbox('showDignities'),
                'q': () => toggleCheckbox('showQualities'),
                'm': () => toggleCheckbox('showElements'),
                's': () => toggleCheckbox('showSeason'),
                'i': () => toggleCheckbox('showSolarIngress'),
                'f': () => toggleCheckbox('showFigureSigns'),
                'b': () => toggleCheckbox('showFertileBarren'),
                't': () => toggleCheckbox('showSignTemps'),
                'n': () => toggleCheckbox('showSignGenders'),
                '1': () => toggleCheckbox('showPlanetTemps'),
                '2': () => toggleCheckbox('showPlanetSect'),
                '3': () => toggleCheckbox('showBeneficMaleficPlanets'),
                '4': () => toggleCheckbox('showPlanetGender'),
                '5': () => toggleCheckbox('showHouseSect'),
                '6': () => toggleCheckbox('showHouseTypes'),
                '7': () => toggleCheckbox('showhouseJoy'),
                '8': () => toggleCheckbox('showEgyptianBounds'),
                '9': () => toggleCheckbox('showPtolemyBounds'),
                '0': () => toggleCheckbox('showChaldeanBounds'),
                'o': () => toggleCheckbox('showDecans'),
                'j': () => toggleCheckbox('showDirections'),
                'a': () => toggleCheckbox('showAngles'),
                'h': () => toggleCheckbox('hideZodiac'),
                'k': () => toggleCheckbox('hidePlanets'),
                'u': () => toggleCheckbox('freeSymbolMovement'),
                'z': () => UI.setMode('zodiac'),
                'x': () => UI.setMode('houses'),
                'v': () => UI.setMode('planets'),
                'w': () => UI.setMode('draw'),
                'p': () => { if (state.mode === 'draw') setDrawTool('pencil'); },
                'l': () => { if (state.mode === 'draw') setDrawTool('line'); },
                'e': () => { if (state.mode === 'draw') setDrawTool('eraser'); },
                'c': () => { if (state.mode === 'draw') UI.clearDrawing(); }
            };

            if (keyMap[e.key.toLowerCase()]) {
                keyMap[e.key.toLowerCase()]();
                e.preventDefault();
                return;
            }

            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const increment = e.key === 'ArrowLeft' ? 1 : -1;
                if (state.mode === 'zodiac' && state.selectedSign !== null) {
                    state.zodiacOffset = Utils.normalizeAngle(state.zodiacOffset + increment);
                    Renderer.drawChart();
                    e.preventDefault();
                } else if (state.mode === 'planets' && state.selectedPlanet !== null) {
                    planets[state.selectedPlanet].angle = Utils.normalizeAngle(planets[state.selectedPlanet].angle + increment);
                    Renderer.drawChart();
                    e.preventDefault();
                } else if (document.getElementById('showAngles')?.checked) {
                    state.ascendantOffset = Utils.normalizeAngle(state.ascendantOffset + increment);
                    Renderer.drawChart();
                    e.preventDefault();
                }
            }
        }
    };

    // Utility Functions
    const toggleCheckbox = (id) => {
        const checkbox = document.getElementById(id);
        if (checkbox) {
            checkbox.checked = !checkbox.checked;
            if (id === 'hideZodiac') state.hideZodiac = checkbox.checked;
            if (id === 'hidePlanets') state.hidePlanets = checkbox.checked;
            Renderer.drawChart();
        }
    };

    const setDrawTool = (tool) => {
        const drawTool = document.getElementById('drawTool');
        if (drawTool) drawTool.value = tool;
    };

    // Initialization
    const initEvents = () => {
        const canvas = CONFIG.canvas;
        if (!canvas) return;

        // Touch events for mobile
        if (CONFIG.isMobile) {
            canvas.addEventListener('touchstart', e => Events.handlePointerEvent(e, 'start'), {passive: false});
            canvas.addEventListener('touchmove', e => Events.handlePointerEvent(e, 'move'), {passive: false});
            canvas.addEventListener('touchend', e => Events.handlePointerEvent(e, 'end'), {passive: false});
        } else {
            canvas.addEventListener('mousedown', e => Events.handlePointerEvent(e, 'start'));
            canvas.addEventListener('mousemove', e => Events.handlePointerEvent(e, 'move'));
            canvas.addEventListener('mouseup', e => Events.handlePointerEvent(e, 'end'));
        }

        canvas.addEventListener('click', Events.handleClick);
        canvas.addEventListener('touchend', e => {
        if (!state.isDragging && e.changedTouches.length === 1) Events.handleClick(e);
        });
        canvas.addEventListener('mouseleave', () => {
            const indicator = document.getElementById('eraserIndicator');
            if (indicator) indicator.style.display = 'none';
        });
        document.addEventListener('keydown', Events.handleKeyDown);

        // Planet selector
        const planetSelect = document.getElementById('planetSelect');
        if (planetSelect) {
            planetSelect.addEventListener('change', e => {
                if (!e.target.value) return;
                const planetData = {
                    symbols: {'☉':'Sun','☽':'Moon','☿':'Mercury','♀':'Venus','♂':'Mars','♃':'Jupiter','♄':'Saturn','☊':'North Node','☋':'South Node','⦻':'Part of Fortune', '℞':'Retrograde', '⭐':'Star'},
                    colors: {'☉':'#FFD700','☽':'#C0C0C0','☿':'#FFA500','♀':'#32CD32','♂':'#FF4500','♃':'#4169E1','♄':'#8B4513','☊':'#FFE4B5','☋':'#DDA0DD','⦻':'#20B2AA', '℞':'#20B2AA', '⭐':'#20B2AA'},
                    textColors: {'☉':'#000','☽':'#000','☿':'#000','♀':'#000','♂':'#000','♃':'#000','♄':'#000','☊':'#000','☋':'#000','⦻':'#000', '℞':'#FF0000', '⭐':'#FF0000'},
                    showCircle: {'☉':true,'☽':true,'☿':true,'♀':true,'♂':true,'♃':true,'♄':true,'☊':true,'☋':true,'⦻':true, '℞':false, '⭐':false}
                };
                planets.push({
                    symbol: e.target.value,
                    name: planetData.symbols[e.target.value],
                    angle: Math.random() * 360,
                    color: planetData.colors[e.target.value],
                    textColor: planetData.textColors[e.target.value] || '#000',
                    showCircle: planetData.showCircle[e.target.value] !== false
                });
                e.target.value = '';
                Renderer.drawChart();
            });
        }

        // Draw controls
        const drawTool = document.getElementById('drawTool');
        if (drawTool) {
            drawTool.addEventListener('change', e => {
                const tool = e.target.value;
                if (state.mode === 'draw') {
                    CONFIG.canvas.style.cursor = tool === 'eraser' ? 'none' : 'crosshair';
                    if (tool !== 'eraser') {
                        const indicator = document.getElementById('eraserIndicator');
                        if (indicator) indicator.style.display = 'none';
                    }
                }
            });
        }

        const drawSize = document.getElementById('drawSize');
        if (drawSize) {
            drawSize.addEventListener('input', e => {
                const sizeValue = document.getElementById('sizeValue');
                if (sizeValue) sizeValue.textContent = e.target.value + 'px';
            });
        }

        // Checkbox listeners
        const checkboxIds = [
            'showInfo','showDignities','showQualities','showElements','showSeason','showFigureSigns',
            'showSolarIngress','showFertileBarren','showSignTemps','showSignGenders','showAngles',
            'showPlanetTemps','showPlanetSect','showBeneficMaleficPlanets','showPlanetGender',
            'showHouseSect','showHouseTypes','showhouseJoy','showEgyptianBounds','showPtolemyBounds',
            'showChaldeanBounds','showDecans','showDirections','hideZodiac','hidePlanets',
            // ADD these new checkbox IDs:
            'showMoonCircle','showMercuryCircle','showVenusCircle','showSunCircle',
            'showMarsCircle','showJupiterCircle','showSaturnCircle', 'showPlanetCircles'
        ];

        checkboxIds.forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.addEventListener('change', () => {
                    if (id === 'hideZodiac') state.hideZodiac = checkbox.checked;
                    if (id === 'hidePlanets') state.hidePlanets = checkbox.checked;
                    Renderer.drawChart();
                });
            }
        });
    };

    // Public API
    return {
        setMode: UI.setMode,
        updateInfo: UI.updateInfo,
        clearDrawing: UI.clearDrawing,
        resetChart: UI.resetChart,
        drawChart: Renderer.drawChart,
        init: () => {
            initEvents();
            Renderer.drawChart();
            UI.updateInfo();
            console.log('Professional Astrology Chart Engine v5.0 - Optimized & Ready');
            console.log('Keyboard Shortcuts: R-Reset | D-Details | G-Dignities | Q-Qualities | U-Elements | S-Seasons | A-Angles | H-Hide Zodiac | K-Hide Planets | Z-Zodiac | X-Houses | V-Planets | W-Draw');
            console.log('Draw Mode: P-Pencil | L-Line | E-Eraser | C-Clear');
        }
    };
})();

// Global bindings
window.setMode = AstrologyChart.setMode;
window.clearDrawing = AstrologyChart.clearDrawing;
window.resetChart = AstrologyChart.resetChart;
window.addEventListener('load', AstrologyChart.init);
</script>
</body>
</html>
